\section{Introduction}%
\label{sec:Introduction}
% The grove paper lists the problems plaguing version control systems and explains how grove addresses them. 

% I guess I should talk about live programming motivation, the marking process, and incremental idea, and then state that we're presenting an incrementalized marking. Also talk about interleaved updates and edits, and computational wiki?

Traditional programming language implementations are 
designed for batch usage with complete programs, so they often struggle to keep up
with the demands of live programming environments, which aim to provide \emph{live} (i.e. continuously available) semantic feedback to the programmer throughout the editing process, even when the program is incomplete or contains localized errors~\cite{omar2017a}.

This paper focuses on the problem of providing live \emph{type information} while a program sketch (i.e. a program with syntactic \emph{holes} in various positions) is being edited. By type information, we mean the locations and causes of type errors as well as information about the expected and actual type at \emph{every} location in the program sketch, even in the presence of type errors at other locations. 
In order to achieve liveness, our central constraint is that the system must not need to traverse the entire program sketch (which we assume to be arbitrarily large) between edits. Instead, the system should be able to \emph{incrementally} update the collected type information, at a computational cost proportional to the number of potentially affected locations. 

Even this essential computational cost may be inherently high for some changes to large programs, so we go further and aim to minimize situations where editing is blocked waiting for updates to the type information to propagate, and eliminate situations where updates caused by previous edits are rolled back and recomputed when a subsequent edit is performed. Instead, we allow updates to propagate at finite speed through the program sketch, even as new edits come in, with correctness guaranteed once this interleaving of edits and updates has fully quiesced.

These uncompromising technical aims are motivated both by the increasing prevalence of multi-million-line code bases (often organized into ``monorepos'') in many organizations, and by a vision of the future of programming in which large-scale scientific and social collaborations occur within a shared, live programming environment that allows thousands of participants to collaboratively edit a single ``planetary-scale'' live program~\cite{hazel-propl,holcomb2023case}. 
%In this case, the size of the program would be such that even a perfectly incremental typing algorithm may take a long time to process an individual edit. This is because a single edit may cause visible changes to the type information at arbitrary locations (for example, changing the type of a function body within a nested stack of functions changes the types of the whole stack), and therefore may necessarily cost computation time linear in the size of the program. A direct approach to incremental typing would \textit{block} further edits while this large update is being computed. 

In pursuit of these aims, this paper develops a foundational type-theoretic calculus of incremental type information maintenance for a bidirectional type system (i.e. a type system organized around local type inference)~\cite{DBLP:journals/csur/DunfieldK21,pierce2000}. We equip this calculus with a comprehensive metatheory mechanized in the Agda proof assistant. Based on this core calculus, we develop an implementation that employs techniques pioneered in web browsers for incremental page layout computations \cite{ST}---most centrally, the use of order maintenance data structures \cite{DBLP:conf/esa/BenderCDFZ02}---to realize the promised speedups. 

We start in \autoref{sec:Background} by reviewing the necessary background on bidirectional typing~\cite{DBLP:journals/csur/DunfieldK21,pierce2000}, gradual typing~\cite{siek2006,siek2015}, and the \emph{marked lambda calculus (MLC)}~\cite{DBLP:journals/pacmpl/ZhaoMDBPO24}, which specifies a total procedure for bidirectional type error marking. In \autoref{sec:MALC} we develop a variant of this calculus, called the \emph{marked and annotated lambda calculus (MALC)}, which simplifies the specification of error marking and adds additional annotations recording the expected and inferred types at each location in the program. Collectively, we call error marks and type annotations \emph{type information}. We also introduce a calculus of purely syntactic structural edit actions on MALC terms. We expect that these tree-structured edit actions will be generated either directly by a structure editor like Hazel~\cite{omar2017b}, Scratch~\cite{maloney2010scratch}, or Pantograph~\cite{prinz2025pantograph}, or else that they will be inferred by a parser together with a tree differencing algorithm~\cite{chawathe1997meaningful}; incrementalizing these systems is beyond the scope of this paper.

We then proceed to the central problem confronted by this paper: incrementalizing the static semantics of MALC in response to these structural edits. We start with an overview of Incremental MALC by example in \autoref{sec:Example} and then fully specify its semantics and metatheory in \autoref{sec:Formalism}. The key idea is to specify the semantics of type information updates as a small-step \emph{update propagation} dynamics. During update propagation, the calculus maintains an \emph{update propagation frontier} through the use of dirty bits on the types within MALC terms. Each update propagation step considers a dirty type at the frontier, calculates its local ramifications, and propagates the frontier correspondingly. This process is kicked off by Incremental MALC's edit action semantics, which creates initial dirty bits at the location of the edit, and critically, at other locations implied by the binding structure of the program. We show that edit actions and updates can be interleaved confluently. Consequently, editing is only blocked for the duration of individual edits and propagation steps, which are generally very short. We establish that correctness (with respect to MALC's semantics) is ensured once update propagation quiesces, i.e. when the frontier is empty.

Incremental MALC specifies certain critical operations related to bindings declaratively, in the usual type-theoretic style, and naive implementations of these operations would require substantial subtree traversals. We turn in \autoref{sec:Implementation} to developing the data structures and algorithms necessary to efficiently implement Incremental MALC. We call our implementation Malcom, a portmanteau of MALC and ``order maintenance'' due to the central role of efficient order maintenance data structures in the implementation. 
We then evaluate the performance of Malcom in \autoref{sec:Evaluation}, comparing the incremental implementation to the from-scratch implementation. We find that for partially randomized edits to a large synthetic functional program designed to serve as a stress-test, a $275.96\times$ speedup is obtained relative to the same system in from-scratch mode.
We conclude with a review of related work in \autoref{sec:Related Work} and discussion and directions for future research in \autoref{sec:Discussion and Conclusion}.

% \subsubsection*{The Binding Problem} This strategy exploits the locality of our chosen type system, in which static information at each point in the syntax tree is determined by neighboring types and syntax nodes. This allows update propagation to flow through the tree in small, efficient steps. However, there is one crucial component of the type system that is not local in this way: variable bindings. The type of a variable occurrence in a program is not determined by anything syntactically near the occurrence, but rather by the ancestor in the syntax tree where the variable is bound. This non-locality is a significant obstacle to maintaining typing information efficiently during structural edits. Consider, for example, a case in which a user deletes a variable binder, such as a function abstraction. Now the types of all of the variables that used to be bound by this abstraction must be updated, which na\"ively would require traversing the entire body of the deleted binder. Additionally, the new type of these variable occurrences is dictated by an outer binder for the same variable name, if there is one, and to find this na\"ively requires traversing the spine of the program from the deleted binder. Such traversals may be linear in the size of the program, so should be avoided. 

% Following related work on incrementalized browser compuations, our solution to the binding problem utilizes an \textit{order maintenance} data structure to represent the topology of the syntax tree. This data structure, paired with balanced search trees representing sets of variables and sets of binder, supports efficient ``nonlocal" queries, such as finding the lowest binder containing a given variable occurrence.

% \subsubsection*{Paper Outline} Section~\ref{sec:Background} reviews the ideas of the \textit{marked lambda calculus}, and presents a novel variant, the \textit{type annotated lambda calculus} (TALC). The TALC serves as the base type system that this work incrementalizes. It also presents the set of edit actions supported by our system. Section~\ref{sec:Example} explains an example trace of edits and update propagation steps through a small program, introducing the formal syntax of the theory and demonstrating the key behaviors of its operations. Section~\ref{sec:Formalism} presents the \textit{incremental type annotated lambda calculus}, the formal system describing our incremental edit action and update propagation logic. It includes a formal statement and informal proof sketch of the main theorems of the calculus. Section~\ref{sec:Implementation} discussions the solutions to various algorithmic questions left open by the incremental TALC, foremost among which is the binding problem. It is in this section that the role of order maintenance is explained. These solutions are implemented in the TALCOM language workbench. Section~\ref{sec:Evaluation} contains a quantitative comparison between the runtimes for the incremental analysis and the from-scratch analysis, demonstrating [TODO]. Section~\ref{sec:Related Work} reviews related work and section~\ref{sec:Discussion and Conclusion} concludes with a discussion and directions for future work. 